<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Sensor Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f9f9f9;
    }
    .container {
      max-width: 900px;
      margin: 0 auto;
      background: #fff;
      border-radius: 8px;
      padding: 20px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }
    canvas {
      max-width: 100%;
      height: 300px !important;
    }
    label {
      display: inline-block;
      margin: 5px 10px 5px 0;
    }
    input, select, button {
      padding: 6px 10px;
      margin: 5px 5px 10px 0;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 14px;
    }
    button {
      background-color: #007bff;
      color: #fff;
      border: none;
      cursor: pointer;
    }
    button:hover {
      background-color: #0056b3;
    }
    #latest {
      font-weight: bold;
      margin: 10px 0;
    }
    
    .navbar {
  background-color: #007bff;
  border-radius: 6px;
  padding: 8px 12px;
  margin-bottom: 20px;
  display: flex;
  justify-content: flex-start;
}

.navbar a {
  color: white;
  margin-right: 20px;
  text-decoration: none;
  font-weight: bold;
  font-size: 14px;
}

.navbar a:hover {
  text-decoration: underline;
}

  </style>
</head>
<body>
  <div class="container">

      <div class="navbar">
      <a href="index.html">Dashboard</a>
      <a href="admin.html">Advanced Config</a>
    </div>
  
    <h2>Sensor Temperature Dashboard</h2>

    <label for="roomSelect">Chọn Phòng:</label>
    <select id="roomSelect" onchange="onRoomChange()"></select>
    <br>

    <label for="fromTime">From:</label>
    <input type="datetime-local" id="fromTime" />
    <label for="toTime">To:</label>
    <input type="datetime-local" id="toTime" />
    <button onclick="updateChart()">Load Range</button>
    <button onclick="loadCurrent()">Show Latest</button>
    <br>

    <label for="intervalInput">Update Interval (sec):</label>
    <input type="number" id="intervalInput" value="5" min="1" />
    <button onclick="updateNow()">Update Now</button>
    <button onclick="toggleAutoUpdate()" id="toggleBtn">Stop Auto-Update</button>
    <br>

    <div id="latest"></div>
    <div id="sensorCharts"></div>

    <br>
    <button onclick="playAnimation()">Play Animation</button>
    <button onclick="pauseAnimation()">Pause</button>
    <button onclick="resetAnimation()">Reset</button>
    <label for="speedSlider">Speed:</label>
    <input type="range" id="speedSlider" min="100" max="2000" step="100" value="1000" />
    

  
  </div>

  <script>
    let sensorMapping = {}; // sensor_id => { room_id, type }
    let roomToSensors = {}; // room_id => [{sensor_id, type}]
    const apiBase = `${location.protocol}//${location.hostname}:5000`;
    let chart, autoUpdate = true, updateTimer, currentSensorId = null, fullData = [], animationTimer, animationIndex = 0;
    let currentRoomId = null;
    let currentSensors = [];
    let activeCharts = {}; // sensorId => Chart instance
    let updateInterval = null;



    async function fetchRoomSensorMappings() {
  const mapRes = await fetch(`${apiBase}/room-sensors-map`);
  sensorMapping = await mapRes.json();

  roomToSensors = {};
  for (const [sid, info] of Object.entries(sensorMapping)) {
    const room = info.room_id;
    if (!roomToSensors[room]) roomToSensors[room] = [];
    roomToSensors[room].push({ sensor_id: sid, type: info.type });
  }

  const roomRes = await fetch(`${apiBase}/rooms`);
  const rooms = await roomRes.json();
  const select = document.getElementById("roomSelect");
  select.innerHTML = "";
  rooms.forEach(r => {
    const opt = document.createElement("option");
    opt.value = r;
    opt.text = `Phòng ${r}`;
    select.appendChild(opt);
  });
  onRoomChange();
  }

    function onSensorChange() {
      currentSensorId = document.getElementById("sensorSelect").value;
      updateChart();
    }

async function updateChart() {
  if (!currentSensors || currentSensors.length === 0) return;

  const from = document.getElementById("fromTime").value;
  const to = document.getElementById("toTime").value;

  for (const sensor of currentSensors) {
    const sensorId = sensor.sensor_id;
    let url = `${apiBase}/sensor/${sensorId}/history`;

    if (from && to) {
      url += `?from=${Math.floor(new Date(from).getTime() / 1000)}&to=${Math.floor(new Date(to).getTime() / 1000)}`;
    }

    try {
      const res = await fetch(url);
      const data = await res.json();
      const labels = data.map(d => new Date(d.timestamp * 1000).toLocaleTimeString());
      const values = data.map(d => d.value);

      const chart = activeCharts[sensorId];
      if (chart) {
        chart.data.labels = labels;
        chart.data.datasets[0].data = values;
        chart.update();
      }
    } catch (err) {
      console.error(`UpdateChart error sensor ${sensorId}:`, err);
    }
  }
}

async function showLast() {
  if (!currentSensors || currentSensors.length === 0) return;

  const now = Math.floor(Date.now() / 1000);
  const fromTime = now - 15 * 60;

  for (const sensor of currentSensors) {
    const sensorId = sensor.sensor_id;

    try {
      const res = await fetch(`${apiBase}/sensor/${sensorId}/range?from=${fromTime}&to=${now}`);
      const data = await res.json();

      if (!Array.isArray(data) || data.length === 0) continue;

      const labels = data.map(d => new Date(d.timestamp * 1000).toLocaleTimeString());
      const values = data.map(d => d.value);

      const chart = activeCharts[sensorId];
      if (chart) {
        chart.data.labels = labels;
        chart.data.datasets[0].data = values;
        chart.update();
      }
    } catch (err) {
      console.error(`Error loading 15-minute data for sensor ${sensorId}:`, err);
    }
  }
}

function loadCurrent() {
  // 1. Gọi ngay 1 lần để hiển thị dữ liệu 15 phút gần nhất
  showLast();

  // 2. Dừng mọi auto-update cũ nếu có
  clearInterval(updateTimer);

  // 3. Lấy giá trị interval từ input (giây → mili giây)
  const interval = parseInt(document.getElementById("intervalInput")?.value || "5") * 1000;

  // 4. Lặp lại showLast sau mỗi interval
  updateTimer = setInterval(showLast, interval);

  // 5. Cập nhật trạng thái và giao diện
  autoUpdate = true;
  document.getElementById("toggleBtn").innerText = "Stop Auto-Update";
}

    async function updateLatest() {
      const res = await fetch(`${apiBase}/sensor/${currentSensorId}/latest`);
      const { sensor_value, timestamp } = await res.json();
      document.getElementById("latest").textContent = `Temperature: ${sensor_value} Celsius, Last update: ${new Date(timestamp * 1000).toLocaleTimeString()}`;
    }

    function toggleAutoUpdate() {
      autoUpdate = !autoUpdate;
      document.getElementById("toggleBtn").innerText = autoUpdate ? "Stop Auto-Update" : "Start Auto-Update";
      if (autoUpdate) startAutoUpdate();
      else clearInterval(updateInterval);
    }

function startAutoUpdate() {
  clearInterval(updateTimer);
  const interval = parseInt(document.getElementById("intervalInput").value) * 1000;
  updateTimer = setInterval(updateChart, interval);
}

function updateNow() {
  updateChart();
  autoUpdate = true;
  document.getElementById("toggleBtn").innerText = "Stop Auto-Update";
  startAutoUpdate();
}

    function playAnimation() {
      if (!fullData.length) return;
      clearInterval(animationTimer);
      animationIndex = 0;
      const speed = parseInt(document.getElementById("speedSlider").value);
      animationTimer = setInterval(() => {
        const slice = fullData.slice(0, animationIndex + 1);
        chart.data.labels = slice.map(d => new Date(d.timestamp * 1000).toLocaleTimeString());
        chart.data.datasets[0].data = slice.map(d => d.value);
        chart.update();
        animationIndex++;
        if (animationIndex >= fullData.length) clearInterval(animationTimer);
      }, speed);
    }

    function pauseAnimation() { clearInterval(animationTimer); }
    function resetAnimation() {
      pauseAnimation();
      animationIndex = 0;
      chart.data.labels = [];
      chart.data.datasets[0].data = [];
      chart.update();
    }

    function onRoomChange() {
  const roomId = document.getElementById("roomSelect").value;
  const sensors = roomToSensors[roomId];
  if (!sensors || sensors.length === 0) return;
  drawChartsForRoom(roomId, sensors);
}

async function drawChartsForRoom(roomId, sensors) {
  const container = document.getElementById("sensorCharts");
  container.innerHTML = ""; // clear old charts

  currentRoomId = roomId;
  currentSensors = sensors;
  activeCharts = {};
  if (updateInterval) clearInterval(updateInterval);

  const types = ["temperature", "humidity", "light"];
  const typeToSensor = {};

  for (const sensor of sensors) {
    typeToSensor[sensor.type] = sensor.sensor_id;
  }

  for (const type of types) {
    const sensorId = typeToSensor[type];
    let values = [], labels = [];

    if (sensorId) {
      try {
        const res = await fetch(`${apiBase}/sensor/${sensorId}/history`);
        const data = await res.json();
        labels = data.map(d => new Date(d.timestamp * 1000).toLocaleTimeString());
        values = data.map(d => d.value);
      } catch (err) {
        console.error("Fetch failed:", err);
      }
    }

    if (values.length === 0) {
      const now = new Date();
      for (let i = 9; i >= 0; i--) {
        const t = new Date(now.getTime() - i * 60000);
        labels.push(t.toLocaleTimeString());
        values.push(0);
      }
    }

    const section = document.createElement("section");
    const title = document.createElement("h3");
    title.textContent = `${type.toUpperCase()} (${sensorId || "N/A"})`;
    const canvas = document.createElement("canvas");

    section.appendChild(title);
    section.appendChild(canvas);
    container.appendChild(section);

    const ctx = canvas.getContext("2d");
    const chart = new Chart(ctx, {
      type: 'line',
      data: {
        labels,
        datasets: [{
          label: `${type} (${sensorId || "không có"})`,
          data: values,
          borderColor: 'blue'
        }]
      },
      options: {
        responsive: true,
        scales: { y: { beginAtZero: false } }
      }
    });

    if (sensorId) {
      activeCharts[sensorId] = chart;
    }
  }
}

fetchRoomSensorMappings();
  </script>
</body>
</html>
